# Setting
SAMPLE = True

# Import libraries
from setting import *
from util import *
from preprocess import *

import os
import numpy as np
import pandas as pd

# Ignore warnings
import warnings
warnings.filterwarnings('ignore')

# Set display options
pd.options.display.max_rows = 100
pd.options.display.max_columns = 100
pd.options.display.width = 1000

# Set Global Random Seed -------------------------------------------------------
print_title('Set Global Random Seed')
np.random.seed(SEED)
print_info('Set global random seed to {}'.format(SEED))

# Load data --------------------------------------------------------------------
print_title('Load Data')
print_info('Start loading data')

if SAMPLE:
    train_df = pd.read_csv(TRAIN_DATA_PATH, nrows = 10000, dtype=ORIGIN_LOAD_TYPES, na_values=['UNKNOWN', 'Unknown'])
    # train_df['MachineIdentifier'] = train_df.index.astype('uint32')
else:
    train_df = pd.read_csv(TRAIN_DATA_PATH, dtype=ORIGIN_LOAD_TYPES, na_values=['UNKNOWN', 'Unknown'])
    # train_df['MachineIdentifier'] = train_df.index.astype('uint32')

print_info('Finish loading data')

"""@TODO"""
# Time feature ----------------------------------------------------------------
print_title('Time Features')
features_versions = [col for col in features_to_be_kept if col.lower().endswith('version') or col.lower().endswith('ver') or col == 'OsBuildLab']
print_info("Features (version/ver) indicating time -> To be engineered:")
for col in features_versions:
    print(col)

# EngineVersion
print_info("EngineVersion (Indicating Time) - Feature to be engineered")

# AppVersion
print_info("AppVersion (Indicating Time) - Feature to be engineered")

# AvSigVersion
print_info("AvSigVersion (Indicating Time) - Feature to be engineered")

# OsVer
print_info("OsVer (58 unique levels & Indicating Time) - Feature to be engineered")

# OsBuildLab
print_info("OsBuildLab (663 unique levels & Indicating Time) - engineered - https://www.kaggle.com/nroman/hacking-osbuildlab-feature-updated")

# Census_OSVersion
print_info("Census_OSVersion (Indicating Time) - Feature to be engineered")

"""@TODO"""
# Related features -------------------------------------------------------------
print_title('Related Features')
features_related = [['EngineVersion','AvSigVersion'],
                    ['OsVer', 'Census_OSVersion'],
                    ['CountryIdentifier', 'CityIdentifier', 'GeoNameIdentifier', 'LocaleEnglishNameIdentifier'],
                    ['OsVer', 'OsBuild', 'OsSuite', 'OsPlatformSubRelease', 'OsBuildLab', 'Census_OSVersion', 'Census_OSArchitecture', 'Census_OSBranch', 'Census_OSBuildNumber', 'Census_OSBuildRevision'],
                    ['Census_OEMNameIdentifier', 'Census_OEMModelIdentifier'],  # Some CountryIdentifier have duplicated CityIdentifier]
                    ['Census_ProcessorManufacturerIdentifier', 'Census_ProcessorModelIdentifier'], # Census_ProcessorModelIdentifier for a Census_ProcessorManufacturerIdentifier
                    ['Census_OSEdition', 'Census_OSSkuName']]

print_info("Features related -> To be explored & engineered:")
for col in features_related:
    print(col)

train_df[features_related[6]]

"""@TODO"""
# Data Encoding ----------------------------------------------------------------
print_title('Feature Encoding')

column = 'RtpStateBitfield'
labels = ['7', '0']
df = train_df
target = TARGET
target_mean = 0.5
labels_count = 3

def encode_BE(df, column, labels):
    print_info('Binary Encoding {}: {}'.format(column, labels))
    for label in labels:
        df['{}_BE_{}'.format(column, label)] = (df[column] == label).astype(int)
    return ['{}_BE_{}'.format(column, label) for label in labels]

def encode_TE_train(df, column, labels, target, target_mean):
    print_info('Target Encoding {}: {}'.format(column, labels))
    column_df = df[[column, target]]
    column_df['target_sum'] = column_df[column].map(column_df.groupby([column])[target].sum())
    column_df['target_sum_leave_one_out'] = column_df['target_sum'] - column_df[target]
    df['{}_TE'.format(column)] = column_df.apply(lambda row: row['target_sum_leave_one_out'] / column_df.shape[0] if row[column] in labels else mean, 1).fillna(target_mean)

    encoding = {key:value for key, value in dict(column_df.groupby([column])[target].mean()).items() if key in labels}
    return encoding

def encode_TE_test(df, column, encoding, target_mean):
    print_info('Target Encoding {}: {}'.format(column, labels))
    df['{}_TE'.format(column)] = df[column].map(encoding).fillna(target_mean)

def encode_FE_train(df, column):
    encoding = df[column].value_counts()
    encoding = encoding / encoding.max()
    encoding = dict(encoding)
    df['{}_FE'.format(column)] = df[column].map(encoding)
    print_info('Frequency Encoding {}: corr(target, {} = {})'.format(column, column, df[['{}_FE'.format(column), target]].corr().iloc[0][1]))

    return encoding

def encode_FE_test(df, column, encoding):
    print_info('Frequency Encoding {}'.format(column))
    df['{}_FE'.format(column)] = df[column].map(encoding)



# Census_InternalBatteryNumberOfCharges
print_info("Census_InternalBatteryNumberOfCharges (3.01% Missing & 25.38% are 4294967296 which represents inf in Python) - (To be encoded)")
encode_BE()

# RtpStateBitfield
print_info("RtpStateBitfield (7 unique levels & Low frequency levels) - Feature to be encoded")

# AVProductStatesIdentifier
print_info("AVProductStatesIdentifier (29870 unique levels & Low frequency levels) - Feature to be encoded")

# CountryIdentifier
print_info("CountryIdentifier (222 unique levels) - Feature to be encoded")

# CityIdentifier
print_info("CityIdentifier (107366 unique levels) - Feature to be encoded")
# df = train_df.groupby(['CountryIdentifier', 'CityIdentifier'])['MachineIdentifier'].count().reset_index()
# df[df['CityIdentifier'].isin(df[df.duplicated(subset = ['CityIdentifier'])]['CityIdentifier'])].sort_values(['CityIdentifier']).shape

# OrganizationIdentifier
print_info("OrganizationIdentifier (49 unique levels) - Feature to be encoded")

# GeoNameIdentifier
print_info("GeoNameIdentifier (292 unique levels) - Feature to be encoded")
# df = train_df.groupby(['CountryIdentifier', 'GeoNameIdentifier'])['MachineIdentifier'].count().reset_index()
# df[df['GeoNameIdentifier'].isin(df[df.duplicated(subset = ['GeoNameIdentifier'])]['GeoNameIdentifier'])].sort_values(['GeoNameIdentifier'])

# LocaleEnglishNameIdentifier
print_info("LocaleEnglishNameIdentifier (276 unique levels) - Feature to be encoded")

# Platform
print_info("Platform (4 unique levels) - Feature to be encoded")

# Processor
print_info("Processor (4 unique levels) - Feature to be encoded")

# OsBuild
print_info("OsBuild (76 unique levels) - Feature to be encoded")

# OsSuite
print_info("OsSuite (14 unique levels) - Feature to be encoded")

# OsPlatformSubRelease
print_info("OsPlatformSubRelease (9 unique levels) - Feature to be encoded")

# SkuEdition
print_info("SkuEdition (8 unique levels & Low frequency levels) - Feature to be encoded")

# IeVerIdentifier
print_info("IeVerIdentifier (303 unique levels) - Feature to be encoded")

# SmartScreen
print_info("SmartScreen (21 unique levels - Feature to be encoded")

# Census_MDC2FormFactor
print_info("Census_MDC2FormFactor (13 unique levels) - Feature to be encoded")

# Census_OEMNameIdentifier
print_info("Census_OEMNameIdentifier (3832 unique levels) - Feature to be encoded")

# Census_OEMModelIdentifier
print_info("Census_OEMModelIdentifier (175365 unique levels) - Feature to be encoded")
# len(train_df['Census_OEMModelIdentifier'].unique())
# df = train_df.groupby(['Census_OEMNameIdentifier', 'Census_OEMModelIdentifier'])['MachineIdentifier'].count().reset_index()
# df.shape
# df[df['Census_OEMModelIdentifier'].isin(df[df.duplicated(subset = ['Census_OEMModelIdentifier'])]['Census_OEMModelIdentifier'])].sort_values(['Census_OEMModelIdentifier'])
# train_df[(~pd.isna(train_df['Census_OEMNameIdentifier'])) & (pd.isna(train_df['Census_OEMModelIdentifier']))].shape
# train_df[(pd.isna(train_df['Census_OEMNameIdentifier'])) & (~pd.isna(train_df['Census_OEMModelIdentifier']))].shape
# train_df[(pd.isna(train_df['Census_OEMNameIdentifier'])) & (pd.isna(train_df['Census_OEMModelIdentifier']))].shape

# Census_ProcessorManufacturerIdentifier
print_info("Census_ProcessorManufacturerIdentifier (7 unique levels & Low frequency levels) - Feature to be encoded")

# Census_ProcessorModelIdentifier
print_info("Census_ProcessorModelIdentifier (3428 unique levels) - Feature to be encoded")
# len(train_df['Census_ProcessorModelIdentifier'].unique())
# df = train_df.groupby(['Census_ProcessorManufacturerIdentifier', 'Census_ProcessorModelIdentifier'])['MachineIdentifier'].count().reset_index()
# df.shape
# df[df['Census_ProcessorModelIdentifier'].isin(df[df.duplicated(subset = ['Census_ProcessorModelIdentifier'])]['Census_ProcessorModelIdentifier'])].sort_values(['Census_ProcessorModelIdentifier'])
# train_df[(~pd.isna(train_df['Census_ProcessorManufacturerIdentifier'])) & (pd.isna(train_df['Census_ProcessorModelIdentifier']))].shape
# train_df[(pd.isna(train_df['Census_ProcessorManufacturerIdentifier'])) & (~pd.isna(train_df['Census_ProcessorModelIdentifier']))].shape
# train_df[(pd.isna(train_df['Census_ProcessorManufacturerIdentifier'])) & (pd.isna(train_df['Census_ProcessorModelIdentifier']))].shape

# Census_PrimaryDiskTypeName
print_info("Census_PrimaryDiskTypeName (5 unique levels) - To be encoded")
# train_df['Census_PrimaryDiskTypeName'] = train_df['Census_PrimaryDiskTypeName'].fillna('UNKNOWN')
# get_percentage(train_df, 'Census_PrimaryDiskTypeName')

# Census_ChassisTypeName
print_info("Census_ChassisTypeName () - Feature to be encoded")

# Census_PowerPlatformRoleName
print_info("Census_PowerPlatformRoleName () - Feature to be encoded")

# Census_OSArchitecture
print_info("Census_OSArchitecture (3 unique levels) - Feature to be encoded")

# Census_OSBranch
print_info("Census_OSBranch (32 unique levels) - Feature to be encoded")

# Census_OSBuildNumber
print_info("Census_OSBuildNumber (165 unique levels) - Feature to be encoded")

# Census_OSBuildRevision
print_info("Census_OSBuildRevision (285 unique levels) - Feature to be encoded")

# Census_OSEdition
print_info("Census_OSEdition (33 unique levels) - Feature to be encoded")

# Census_OSSkuName
print_info("Census_OSSkuName (30 unique levels) - Feature to be encoded")

# Census_OSInstallTypeName
print_info("Census_OSInstallTypeName (9 unique levels) - Feature to be encoded")

# Census_OSInstallLanguageIdentifier
print_info("Census_OSInstallLanguageIdentifier (39 unique levels) - Feature to be encoded")

# Census_OSUILocaleIdentifier
print_info("Census_OSUILocaleIdentifier (147 unique levels) - Feature to be encoded")

# Census_OSWUAutoUpdateOptionsName
print_info("Census_OSWUAutoUpdateOptionsName (6 unique levels) - Feature to be encoded")

# Census_GenuineStateName
print_info("Census_GenuineStateName (5 unique levels) - Feature to be encoded")

# Census_ActivationChannel
print_info("Census_ActivationChannel (6 unique levels) - Feature to be encoded")

# Census_FlightRing
print_info("Census_ActivationChannel (10 unique levels) - Feature to be encoded")

# Census_FirmwareManufacturerIdentifier
print_info("Census_FirmwareManufacturerIdentifier () - Feature to be encoded")

# Census_FirmwareVersionIdentifier
print_info("Census_FirmwareVersionIdentifier () - Feature to be encoded")

# Wdft_IsGamer
print_info("Wdft_IsGamer (3 unique levels) - To be encoded")

# Wdft_RegionIdentifier
print_info("Wdft_RegionIdentifier () - To be encoded")
